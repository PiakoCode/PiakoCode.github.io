# 闭包和迭代器

## 闭包

### 使用闭包

闭包是Rust中的一种函数，它可以捕获其周围作用域中的变量，并将其保存为状态。这表示闭包可以在其定义时使用外部的变量值，并且在稍后调用时可以使用这些值。

例如，下面的代码展示了在Rust中定义和使用闭包的示例：

```rust
fn main() {
    let x = 5;

    // 定义一个闭包，它可以访问x变量
    let closure = |y| x + y;

    // 调用闭包
    let result = closure(10);
    println!("The result is {}", result); // 输出 "The result is 15"
}
```

在上面的代码中，我们定义了一个闭包`closure`，它使用外部变量`x`和参数`y`来计算结果。然后我们通过将参数值传递给闭包来调用它，并打印出返回的结果。


### 闭包捕获上下文

在Rust中，闭包可以捕获其定义时所在的上下文，这意味着闭包可以访问它所定义的函数或作用域中的变量。

捕获上下文可以通过三种方式实现：通过值捕获（move闭包）、通过可变引用捕获和通过不可变引用捕获。

例如，下面的代码定义了一个闭包，捕获了一个i32类型的值：

```rust
fn main() {
    let x = 10;
    let add_x = |y| y + x;
    println!("{}", add_x(5)); // 15
}
```

在这个例子中，闭包`add_x`捕获了变量`x`，并将其作为一个不可变引用嵌入到了闭包的定义中。

你也可以通过`move`关键字使闭包通过值捕获变量：

```rust
fn main() {
    let x = vec![1, 2, 3];
    let print_x = move || println!("{:?}", x);
    print_x(); // [1, 2, 3]
    //println!("{:?}", x); // ERROR: borrow of moved value: `x`
}
```

在这个例子中，闭包`print_x`通过值捕获了变量`x`，意味着它拥有`x`的所有权。在闭包执行完毕后，`x`的所有权也会被释放。

最后，你还可以通过可变引用捕获变量：

```rust
fn main() {
    let mut x = 10;
    {
        let add_to_x = |y| x += y;
        add_to_x(5);
    }
    println!("{}", x); // 15
}
```

在这个例子中，闭包`add_to_x`通过可变引用捕获了变量`x`，并修改了它的值。

### 类型推断

显式类型标注允许程序员明确地指定闭包参数和返回值的类型。例如：

```rust
fn main() {
    let add_one = |x: i32| -> i32 {x + 1};
    let result = add_one(1);
    println!("{}", result);
}
```

在这个例子中，我们使用`fn(i32) -> i32`来显式标注闭包的类型，表示这是一个接受一个i32类型参数并返回一个i32类型值的闭包。

## 迭代器

iterators5.rs

Rust提供了迭代器（Iterator）类型，它是一种用于遍历集合（如数组、向量、哈希表等）元素的机制。迭代器提供了一系列方法，可以对集合进行各种操作，如过滤、映射、搜索等。

要使用迭代器，首先需要通过调用集合对象的`iter`方法来创建一个迭代器对象。然后，可以使用迭代器对象上的各种方法进行遍历和操作。

下面是一些常用的迭代器方法：

1. `iter()`：创建一个不可变迭代器，用于遍历集合中的每个元素。
2. `iter_mut()`：创建一个可变迭代器，用于遍历集合中的每个元素并进行修改。
3. `enumerate()`：返回一个元素和其索引的元组的迭代器，可以用于同时遍历集合中的元素和它们的索引。
4. `filter()`：根据指定的条件过滤集合中的元素，返回满足条件的元素的迭代器。
5. `map()`：对集合中的每个元素应用一个函数并返回结果的迭代器。
6. `collect()`：将迭代器中的元素收集到一个集合中，并返回该集合。
7. `take()`：只获取迭代器中的前几个元素。
8. `skip()`：跳过迭代器中的前几个元素。

除了上述方法，还有很多其他的迭代器方法可以在Rust的标准库文档中找到。

下面是一个简单的例子，展示了如何使用迭代器对一个数组进行遍历和操作：

```rust
fn main() {
    let numbers = [1, 2, 3, 4, 5];

    // 遍历并打印数组中的每个元素
    for num in numbers.iter() {
        println!("{}", num);
    }

    // 对数组中的每个元素进行平方操作，并收集到一个向量中
    let squares: Vec<i32> = numbers.iter().map(|&num| num * num).collect();

    // 打印新生成的向量
    println!("{:?}", squares);
}
```

在上面的例子中，我们首先使用`iter`方法创建了一个数组的不可变迭代器，然后使用`for`循环遍历了数组中的每个元素并打印出来。接下来，我们使用`map`方法对数组中的每个元素进行平方操作，然后使用`collect`方法将结果收集到一个向量中，并最后打印出新生成的向量。


要使用HashMap的迭代器，首先需要导入HashMap的模块：

```rust
use std::collections::HashMap;
```

然后，你可以创建一个HashMap，并使用`iter`方法获取它的迭代器：

```rust
let mut map = HashMap::new();
map.insert("key1", "value1");
map.insert("key2", "value2");
map.insert("key3", "value3");

for (key, value) in map.iter() {
    println!("Key: {}, Value: {}", key, value);
}
```

在这个例子中，我们使用`iter`方法获取HashMap的不可变引用，然后使用一个`for`循环来遍历迭代器中的键值对。每个键值对都被解构为一个`key`和一个`value`变量，你可以根据需要对它们进行操作。

### HashMap的迭代器

如果你需要对HashMap的可变引用进行迭代，可以使用`iter_mut`方法：

```rust
for (key, value) in map.iter_mut() {
    *value = "new value";
}
```

在这个例子中，我们使用`iter_mut`方法获取HashMap的可变引用，并使用`*`操作符来修改迭代器中的值。

除了`iter`和`iter_mut`方法外，HashMap还提供了其他一些有用的方法来处理键值对，包括`into_iter`、`keys`和`values`。你可以根据自己的需求选择合适的方法来迭代HashMap的内容。