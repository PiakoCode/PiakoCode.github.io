# Lab: page tables



[操作系统中的多级页表到底是为了解决什么问题？ - 知乎](https://www.zhihu.com/question/63375062/answer/1403291487)

![](Picture/Pasted%20image%2020230727160022.png)

![](Picture/Pasted%20image%2020230729144420.png)



```ascii
  +-----------------------------------+
  |                                   |
  |           程序运行时               |
  |                                   |
  +-----------------+-----------------+
                    |
                    | 使用虚拟地址访问内存
                    |
                    v
  +-----------------+-----------------+
  |                                   |
  |          MMU 硬件模块              |
  |                                   |
  +-----------------+-----------------+
                    |
                    | 通过页表映射，将虚拟地址转换为物理地址
                    |
                    v
  +-----------------+-----------------+
  |                                   |
  |        操作系统的页表              |
  |                                   |
  +-----------------+-----------------+
                    |
                    | 查找虚拟页号对应的物理页号
                    |
                    v
  +-----------------+-----------------+
  |                                   |
  |           物理内存                 |
  |                                   |
  +-----------------+-----------------+

```

解释过程图：

1. 程序运行时，程序使用虚拟地址访问内存。
2. MMU（Memory Management Unit）硬件模块是计算机的一部分，负责虚拟内存地址转换。它接收程序发出的虚拟地址，并通过页表映射将虚拟地址转换为物理地址。
3. 操作系统的页表是存储在内存中的数据结构，它包含虚拟页号与物理页号之间的映射关系。MMU会使用虚拟页号在页表中查找对应的物理页号。
4. 物理内存是实际的内存空间，包含了程序的数据和指令。一旦找到虚拟页号对应的物理页号，MMU会将物理页号与页内偏移组合成物理地址，从而能够访问实际的物理内存。

通过这个过程，程序能够在虚拟内存空间中运行，并且不需要关心物理内存的具体位置和管理，操作系统通过虚拟内存地址转换来完成内存管理的任务。


## 代码

speed up syscall
// todo

### Print a page table

在`defs.h`中添加声明

```c
void            vmprint(pagetable_t, int);
```

`exec.c`中使用vmprint()

```c
+ if (p->pid == 1) 
+   vmprint(p->pagetable, 0);
  return argc; // this ends up in a0, the first argument to main(argc, argv)
```

`vm.c`中实现该函数

```c
void vmprint(pagetable_t pagetable,int depth) {
  if(depth > 2) { // 深度大于2就返回
    return;
  }
  if(depth == 0) { // 深度等于0时输出pagetable
    printf("page table %p\n",pagetable);
  }

  for(int i = 0; i < 512; i++){ // 遍历页表项
    pte_t pte = pagetable[i];
    if(pte & PTE_V) { // 如果可以访问
  
      for(int i=0;i<=depth;i++){ // 处理vmprint的格式
        if(i == 0)
          printf("..");
        else {
          printf(" ..");
        }
      }

      printf("%d: pte %p pa %p\n",i,pte,PTE2PA(pte)); // 输出
      
      uint64 child = PTE2PA(pte); // 下一级
      vmprint((pagetable_t)child,depth+1);
    }
  }
}
```

pa 物理地址

pte 页表

va 虚拟地址

### A kernel page table per process

