---
tags:
  - 计算机网络
---

# CS144

version sponge 2021


**准备**

make时出现错误 ` error: 'out_of_range' was not declared in this scope`

解决方法: 在libsponge/util/buffer.hh中添加`#include <stdexcept>`一行


错误：变量‘std::array<char, 1025> ip’有初始值设定，但是类型不完全 build 91 | array<char, NI_MAXHOST> ip{};

解决方法:  在util.hh添加`#include <array>`
## Lab0

### webget

webget.cc
```cpp
void get_URL(const string &host, const string &path) {
    // Your code here.

    // You will need to connect to the "http" service on
    // the computer whose name is in the "host" string,
    // then request the URL path given in the "path" string.

    // Then you'll need to print out everything the server sends back,
    // (not just one call to read() -- everything) until you reach
    // the "eof" (end of file).

    // 创建socket
    std::shared_ptr<TCPSocket> socket = std::make_shared<TCPSocket>();

    // 绑定地址
    Address address(host, "http");

    // 连接
    socket->connect(address);

    // 发送请求
    string msg = "GET " + path +
                 " HTTP/1.1\r\n"
                 "Host: " +
                 host +
                 "\r\n"
                 "Connection: close\r\n\r\n";

    socket->write(msg);

    string result;
    while (!socket->eof()) {
        result = socket->read(); // 接收
        cout<<result;
    }
}
```

**相关知识:**

Http报文结构

```
GET path HTTP/1.1
Host: host
Connection: keep-alive // 或者 Connection: close
```

![](Picture/Pasted%20image%2020240110165532.png)

### An in-memory reliable byte stream

内存中可靠的字节流

code:

[p0 byte_stream](https://github.com/PiakoCode/sponge/commit/bb60ea4cda52b1cf391b4792f6156415b3830fcb)


## Lab 1

合并无关的分支
```shell
git merge master --allow-unrelated-histories
```

>您要在这个和下一个实验室中实现一个TCP接收器：该模块接收数据报并将其转换为可靠的字节流，以便应用程序通过套接字读取，就像您在实验室0中的webget程序从web服务器读取字节流一样。TCP发送器将其字节流分成短段（每个子字符串不超过大约1460个字节），以便它们每个都能适应一个数据报。但是网络可能会重新排序这些数据报，或者丢弃它们，或者多次交付它们。接收器必须将这些段重新组装成它们最初的连续字节流。
>
>在这个实验室中，您将编写负责这种重组的数据结构：一个StreamReassembler。它将接收子字符串，由字节字符串和该字符串中第一个字节在更大流中的索引组成。流中的每个字节都有自己唯一的索引，从零开始并向上计数。StreamReassembler将拥有一个ByteStream用于输出：一旦重组器知道了流的下一个字节，它就会将其写入ByteStream。所有者可以随时访问和读取ByteStream。

任务:   

implement a TCP receiver

