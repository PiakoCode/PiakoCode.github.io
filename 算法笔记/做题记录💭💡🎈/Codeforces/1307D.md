#BFS #图论 #Codeforces
[Problem - 1307D - Codeforces](https://codeforces.com/problemset/problem/1307/D)
[Cow and Fields - 洛谷](https://www.luogu.com.cn/problem/CF1307D)

# Cow and Fields

## 题面翻译

### 题意简述

给定一个有$n$个节点$m$条边的无向图，一个顶点集$S$。

你需要选择两个顶点$u,v(u\ne v,u\in S,v\in S)$并连接这两个顶点（允许$u,v$之间已经有连边），求连接后从顶点$1$到顶点$n$最短路的最大值。

**注意，该操作仅能进行一次。**

保证给定的图联通。

### 输入格式

第一行3个整数$n,m,k$ ($2 \le n \le 2 \cdot 10^5$,$n-1 \le m \le 2 \cdot 10^5$,$2 \le k \le n$)​，分别表示点数，边数和点集的大小。

第二行$k$个整数$a_1, a_2, \ldots, a_k$($1 \le a_i \le n$)，表示点集。

下面$m$行，每行两个整数，表示这两个整数之间有一条边。

### 输出格式

一行一个整数，表示添加一条边之后从顶点$1$到顶点$n$最短路的最大值

## 题目描述

Bessie is out grazing on the farm, which consists of $ n $ fields connected by $ m $ bidirectional roads. She is currently at field $ 1 $ , and will return to her home at field $ n $ at the end of the day.

The Cowfederation of Barns has ordered Farmer John to install one extra bidirectional road. The farm has $ k $ special fields and he has decided to install the road between two different special fields. He may add the road between two special fields that already had a road directly connecting them.

After the road is added, Bessie will return home on the shortest path from field $ 1 $ to field $ n $ . Since Bessie needs more exercise, Farmer John must maximize the length of this shortest path. Help him!

## 输入格式

The first line contains integers $ n $ , $ m $ , and $ k $ ( $ 2 \le n \le 2 \cdot 10^5 $ , $ n-1 \le m \le 2 \cdot 10^5 $ , $ 2 \le k \le n $ ) — the number of fields on the farm, the number of roads, and the number of special fields.

The second line contains $ k $ integers $ a_1, a_2, \ldots, a_k $ ( $ 1 \le a_i \le n $ ) — the special fields. All $ a_i $ are distinct.

The $ i $ -th of the following $ m $ lines contains integers $ x_i $ and $ y_i $ ( $ 1 \le x_i, y_i \le n $ , $ x_i \ne y_i $ ), representing a bidirectional road between fields $ x_i $ and $ y_i $ .

It is guaranteed that one can reach any field from every other field. It is also guaranteed that for any pair of fields there is at most one road connecting them.

## 输出格式

Output one integer, the maximum possible length of the shortest path from field $ 1 $ to $ n $ after Farmer John installs one road optimally.

## 样例 #1

### 样例输入 #1

```
5 5 3
1 3 5
1 2
2 3
3 4
3 5
2 4
```

### 样例输出 #1

```
3
```

## 样例 #2

### 样例输入 #2

```
5 4 2
2 4
1 2
2 3
3 4
4 5
```

### 样例输出 #2

```
3
```

## 提示

The graph for the first example is shown below. The special fields are denoted by red. It is optimal for Farmer John to add a road between fields $ 3 $ and $ 5 $ , and the resulting shortest path from $ 1 $ to $ 5 $ is length $ 3 $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1307D/a6a22f5ed84788383fc241ea2dde08c9f28bd36f.png)The graph for the second example is shown below. Farmer John must add a road between fields $ 2 $ and $ 4 $ , and the resulting shortest path from $ 1 $ to $ 5 $ is length $ 3 $ .

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1307D/6e910397f1b2c44c166ab9348389635244758f12.png)

# 题解
```cpp
// CF1307D
#include <iostream>
#include <algorithm>
#include <string>
#include <cstring>
#include <vector>
#include <queue>
#include <map>
#include <cmath>
#include <set>

using namespace std;
typedef pair<int, int> PII;
typedef long long LL;

const int INF = 1e9;
const int N = 2e5 + 10;

int n, m, k;
int a[N];
int dis1[N];
int dis2[N];

vector<int> g[N];

queue<int> q;

bool cmp(int x, int y)
{
    return dis1[x] < dis1[y];
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> m >> k;
    for (int i = 1; i <= k; i++)
    {
        cin >> a[i];
    }
    for (int i = 1; i <= m; i++)
    {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    memset(dis1, -1, sizeof(dis1));
    dis1[1] = 0;
    q.push(1);
    while (!q.empty())
    {
        int t = q.front();
        q.pop();
        for (int i = 0; i < g[t].size(); i++)
        {
            if (dis1[g[t][i]] == -1)
            {
                dis1[g[t][i]] = dis1[t] + 1;
                q.push(g[t][i]);
            }
        }
    }
    memset(dis2, -1, sizeof(dis2));
    dis2[n] = 0;
    q.push(n);
    while (!q.empty())
    {
        int t = q.front();
        q.pop();
        for (int i = 0; i < g[t].size(); i++)
        {
            if (dis2[g[t][i]] == -1)
            {
                dis2[g[t][i]] = dis2[t] + 1;
                q.push(g[t][i]);
            }
        }
    }
    sort(a + 1, a + k + 1, cmp);
    int ans = 0;
    for (int i = 1; i <= k; i++)
    {
        ans = max(ans, min(dis1[n], min(dis1[a[i]] + dis2[a[i + 1]], dis1[a[i + 1]] + dis2[a[i]]) + 1));
    }
    cout << ans << endl;
    return 0;
}
```